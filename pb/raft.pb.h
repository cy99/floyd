// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raft/raft.proto

#ifndef PROTOBUF_raft_2fraft_2eproto__INCLUDED
#define PROTOBUF_raft_2fraft_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace floyd {
namespace raft {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_raft_2fraft_2eproto();
void protobuf_AssignDesc_raft_2fraft_2eproto();
void protobuf_ShutdownFile_raft_2fraft_2eproto();

class Entry;
class RequestVote;
class ResponseVote;
class AppendEntriesRequest;
class AppendEntriesResponse;

enum Entry_Type {
  Entry_Type_DATA = 0,
  Entry_Type_NOOP = 1
};
bool Entry_Type_IsValid(int value);
const Entry_Type Entry_Type_Type_MIN = Entry_Type_DATA;
const Entry_Type Entry_Type_Type_MAX = Entry_Type_NOOP;
const int Entry_Type_Type_ARRAYSIZE = Entry_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Entry_Type_descriptor();
inline const ::std::string& Entry_Type_Name(Entry_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Entry_Type_descriptor(), value);
}
inline bool Entry_Type_Parse(
    const ::std::string& name, Entry_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Entry_Type>(
    Entry_Type_descriptor(), name, value);
}
// ===================================================================

class Entry : public ::google::protobuf::Message {
 public:
  Entry();
  virtual ~Entry();

  Entry(const Entry& from);

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entry& default_instance();

  void Swap(Entry* other);

  // implements Message ----------------------------------------------

  Entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entry& from);
  void MergeFrom(const Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Entry_Type Type;
  static const Type DATA = Entry_Type_DATA;
  static const Type NOOP = Entry_Type_NOOP;
  static inline bool Type_IsValid(int value) {
    return Entry_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Entry_Type_Type_MIN;
  static const Type Type_MAX =
    Entry_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Entry_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Entry_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Entry_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Entry_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .floyd.raft.Entry.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::floyd::raft::Entry_Type type() const;
  inline void set_type(::floyd::raft::Entry_Type value);

  // required uint64 term = 2;
  inline bool has_term() const;
  inline void clear_term();
  static const int kTermFieldNumber = 2;
  inline ::google::protobuf::uint64 term() const;
  inline void set_term(::google::protobuf::uint64 value);

  // optional bytes cmd = 3;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 3;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const void* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // @@protoc_insertion_point(class_scope:floyd.raft.Entry)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_term();
  inline void clear_has_term();
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 term_;
  ::std::string* cmd_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_raft_2fraft_2eproto();
  friend void protobuf_AssignDesc_raft_2fraft_2eproto();
  friend void protobuf_ShutdownFile_raft_2fraft_2eproto();

  void InitAsDefaultInstance();
  static Entry* default_instance_;
};
// -------------------------------------------------------------------

class RequestVote : public ::google::protobuf::Message {
 public:
  RequestVote();
  virtual ~RequestVote();

  RequestVote(const RequestVote& from);

  inline RequestVote& operator=(const RequestVote& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestVote& default_instance();

  void Swap(RequestVote* other);

  // implements Message ----------------------------------------------

  RequestVote* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestVote& from);
  void MergeFrom(const RequestVote& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // required uint64 term = 3;
  inline bool has_term() const;
  inline void clear_term();
  static const int kTermFieldNumber = 3;
  inline ::google::protobuf::uint64 term() const;
  inline void set_term(::google::protobuf::uint64 value);

  // required uint64 last_log_term = 4;
  inline bool has_last_log_term() const;
  inline void clear_last_log_term();
  static const int kLastLogTermFieldNumber = 4;
  inline ::google::protobuf::uint64 last_log_term() const;
  inline void set_last_log_term(::google::protobuf::uint64 value);

  // required uint64 last_log_index = 5;
  inline bool has_last_log_index() const;
  inline void clear_last_log_index();
  static const int kLastLogIndexFieldNumber = 5;
  inline ::google::protobuf::uint64 last_log_index() const;
  inline void set_last_log_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:floyd.raft.RequestVote)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_term();
  inline void clear_has_term();
  inline void set_has_last_log_term();
  inline void clear_has_last_log_term();
  inline void set_has_last_log_index();
  inline void clear_has_last_log_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::uint64 term_;
  ::google::protobuf::uint64 last_log_term_;
  ::google::protobuf::uint64 last_log_index_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_raft_2fraft_2eproto();
  friend void protobuf_AssignDesc_raft_2fraft_2eproto();
  friend void protobuf_ShutdownFile_raft_2fraft_2eproto();

  void InitAsDefaultInstance();
  static RequestVote* default_instance_;
};
// -------------------------------------------------------------------

class ResponseVote : public ::google::protobuf::Message {
 public:
  ResponseVote();
  virtual ~ResponseVote();

  ResponseVote(const ResponseVote& from);

  inline ResponseVote& operator=(const ResponseVote& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseVote& default_instance();

  void Swap(ResponseVote* other);

  // implements Message ----------------------------------------------

  ResponseVote* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseVote& from);
  void MergeFrom(const ResponseVote& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 term = 1;
  inline bool has_term() const;
  inline void clear_term();
  static const int kTermFieldNumber = 1;
  inline ::google::protobuf::uint64 term() const;
  inline void set_term(::google::protobuf::uint64 value);

  // required bool granted = 2;
  inline bool has_granted() const;
  inline void clear_granted();
  static const int kGrantedFieldNumber = 2;
  inline bool granted() const;
  inline void set_granted(bool value);

  // @@protoc_insertion_point(class_scope:floyd.raft.ResponseVote)
 private:
  inline void set_has_term();
  inline void clear_has_term();
  inline void set_has_granted();
  inline void clear_has_granted();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 term_;
  bool granted_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_raft_2fraft_2eproto();
  friend void protobuf_AssignDesc_raft_2fraft_2eproto();
  friend void protobuf_ShutdownFile_raft_2fraft_2eproto();

  void InitAsDefaultInstance();
  static ResponseVote* default_instance_;
};
// -------------------------------------------------------------------

class AppendEntriesRequest : public ::google::protobuf::Message {
 public:
  AppendEntriesRequest();
  virtual ~AppendEntriesRequest();

  AppendEntriesRequest(const AppendEntriesRequest& from);

  inline AppendEntriesRequest& operator=(const AppendEntriesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntriesRequest& default_instance();

  void Swap(AppendEntriesRequest* other);

  // implements Message ----------------------------------------------

  AppendEntriesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppendEntriesRequest& from);
  void MergeFrom(const AppendEntriesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // required uint64 term = 3;
  inline bool has_term() const;
  inline void clear_term();
  static const int kTermFieldNumber = 3;
  inline ::google::protobuf::uint64 term() const;
  inline void set_term(::google::protobuf::uint64 value);

  // required uint64 prev_log_index = 4;
  inline bool has_prev_log_index() const;
  inline void clear_prev_log_index();
  static const int kPrevLogIndexFieldNumber = 4;
  inline ::google::protobuf::uint64 prev_log_index() const;
  inline void set_prev_log_index(::google::protobuf::uint64 value);

  // required uint64 prev_log_term = 5;
  inline bool has_prev_log_term() const;
  inline void clear_prev_log_term();
  static const int kPrevLogTermFieldNumber = 5;
  inline ::google::protobuf::uint64 prev_log_term() const;
  inline void set_prev_log_term(::google::protobuf::uint64 value);

  // required uint64 commit_index = 6;
  inline bool has_commit_index() const;
  inline void clear_commit_index();
  static const int kCommitIndexFieldNumber = 6;
  inline ::google::protobuf::uint64 commit_index() const;
  inline void set_commit_index(::google::protobuf::uint64 value);

  // repeated .floyd.raft.Entry entries = 7;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 7;
  inline const ::floyd::raft::Entry& entries(int index) const;
  inline ::floyd::raft::Entry* mutable_entries(int index);
  inline ::floyd::raft::Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::floyd::raft::Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::floyd::raft::Entry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:floyd.raft.AppendEntriesRequest)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_term();
  inline void clear_has_term();
  inline void set_has_prev_log_index();
  inline void clear_has_prev_log_index();
  inline void set_has_prev_log_term();
  inline void clear_has_prev_log_term();
  inline void set_has_commit_index();
  inline void clear_has_commit_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::uint64 term_;
  ::google::protobuf::uint64 prev_log_index_;
  ::google::protobuf::uint64 prev_log_term_;
  ::google::protobuf::uint64 commit_index_;
  ::google::protobuf::RepeatedPtrField< ::floyd::raft::Entry > entries_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_raft_2fraft_2eproto();
  friend void protobuf_AssignDesc_raft_2fraft_2eproto();
  friend void protobuf_ShutdownFile_raft_2fraft_2eproto();

  void InitAsDefaultInstance();
  static AppendEntriesRequest* default_instance_;
};
// -------------------------------------------------------------------

class AppendEntriesResponse : public ::google::protobuf::Message {
 public:
  AppendEntriesResponse();
  virtual ~AppendEntriesResponse();

  AppendEntriesResponse(const AppendEntriesResponse& from);

  inline AppendEntriesResponse& operator=(const AppendEntriesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntriesResponse& default_instance();

  void Swap(AppendEntriesResponse* other);

  // implements Message ----------------------------------------------

  AppendEntriesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppendEntriesResponse& from);
  void MergeFrom(const AppendEntriesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline bool status() const;
  inline void set_status(bool value);

  // required uint64 term = 2;
  inline bool has_term() const;
  inline void clear_term();
  static const int kTermFieldNumber = 2;
  inline ::google::protobuf::uint64 term() const;
  inline void set_term(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:floyd.raft.AppendEntriesResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_term();
  inline void clear_has_term();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 term_;
  bool status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_raft_2fraft_2eproto();
  friend void protobuf_AssignDesc_raft_2fraft_2eproto();
  friend void protobuf_ShutdownFile_raft_2fraft_2eproto();

  void InitAsDefaultInstance();
  static AppendEntriesResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Entry

// required .floyd.raft.Entry.Type type = 1;
inline bool Entry::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entry::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entry::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::floyd::raft::Entry_Type Entry::type() const {
  return static_cast< ::floyd::raft::Entry_Type >(type_);
}
inline void Entry::set_type(::floyd::raft::Entry_Type value) {
  assert(::floyd::raft::Entry_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint64 term = 2;
inline bool Entry::has_term() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entry::set_has_term() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entry::clear_has_term() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entry::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::uint64 Entry::term() const {
  return term_;
}
inline void Entry::set_term(::google::protobuf::uint64 value) {
  set_has_term();
  term_ = value;
}

// optional bytes cmd = 3;
inline bool Entry::has_cmd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entry::set_has_cmd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entry::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entry::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& Entry::cmd() const {
  return *cmd_;
}
inline void Entry::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void Entry::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void Entry::set_cmd(const void* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entry::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* Entry::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Entry::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestVote

// required bytes ip = 1;
inline bool RequestVote::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestVote::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestVote::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestVote::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RequestVote::ip() const {
  return *ip_;
}
inline void RequestVote::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RequestVote::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RequestVote::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestVote::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RequestVote::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestVote::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 2;
inline bool RequestVote::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestVote::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestVote::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestVote::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RequestVote::port() const {
  return port_;
}
inline void RequestVote::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required uint64 term = 3;
inline bool RequestVote::has_term() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestVote::set_has_term() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestVote::clear_has_term() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestVote::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::uint64 RequestVote::term() const {
  return term_;
}
inline void RequestVote::set_term(::google::protobuf::uint64 value) {
  set_has_term();
  term_ = value;
}

// required uint64 last_log_term = 4;
inline bool RequestVote::has_last_log_term() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestVote::set_has_last_log_term() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestVote::clear_has_last_log_term() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestVote::clear_last_log_term() {
  last_log_term_ = GOOGLE_ULONGLONG(0);
  clear_has_last_log_term();
}
inline ::google::protobuf::uint64 RequestVote::last_log_term() const {
  return last_log_term_;
}
inline void RequestVote::set_last_log_term(::google::protobuf::uint64 value) {
  set_has_last_log_term();
  last_log_term_ = value;
}

// required uint64 last_log_index = 5;
inline bool RequestVote::has_last_log_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestVote::set_has_last_log_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestVote::clear_has_last_log_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestVote::clear_last_log_index() {
  last_log_index_ = GOOGLE_ULONGLONG(0);
  clear_has_last_log_index();
}
inline ::google::protobuf::uint64 RequestVote::last_log_index() const {
  return last_log_index_;
}
inline void RequestVote::set_last_log_index(::google::protobuf::uint64 value) {
  set_has_last_log_index();
  last_log_index_ = value;
}

// -------------------------------------------------------------------

// ResponseVote

// required uint64 term = 1;
inline bool ResponseVote::has_term() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseVote::set_has_term() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseVote::clear_has_term() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseVote::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::uint64 ResponseVote::term() const {
  return term_;
}
inline void ResponseVote::set_term(::google::protobuf::uint64 value) {
  set_has_term();
  term_ = value;
}

// required bool granted = 2;
inline bool ResponseVote::has_granted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseVote::set_has_granted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseVote::clear_has_granted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseVote::clear_granted() {
  granted_ = false;
  clear_has_granted();
}
inline bool ResponseVote::granted() const {
  return granted_;
}
inline void ResponseVote::set_granted(bool value) {
  set_has_granted();
  granted_ = value;
}

// -------------------------------------------------------------------

// AppendEntriesRequest

// required bytes ip = 1;
inline bool AppendEntriesRequest::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendEntriesRequest::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendEntriesRequest::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendEntriesRequest::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& AppendEntriesRequest::ip() const {
  return *ip_;
}
inline void AppendEntriesRequest::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AppendEntriesRequest::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void AppendEntriesRequest::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppendEntriesRequest::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* AppendEntriesRequest::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppendEntriesRequest::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 2;
inline bool AppendEntriesRequest::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppendEntriesRequest::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppendEntriesRequest::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppendEntriesRequest::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 AppendEntriesRequest::port() const {
  return port_;
}
inline void AppendEntriesRequest::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required uint64 term = 3;
inline bool AppendEntriesRequest::has_term() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppendEntriesRequest::set_has_term() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppendEntriesRequest::clear_has_term() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppendEntriesRequest::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::uint64 AppendEntriesRequest::term() const {
  return term_;
}
inline void AppendEntriesRequest::set_term(::google::protobuf::uint64 value) {
  set_has_term();
  term_ = value;
}

// required uint64 prev_log_index = 4;
inline bool AppendEntriesRequest::has_prev_log_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppendEntriesRequest::set_has_prev_log_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppendEntriesRequest::clear_has_prev_log_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppendEntriesRequest::clear_prev_log_index() {
  prev_log_index_ = GOOGLE_ULONGLONG(0);
  clear_has_prev_log_index();
}
inline ::google::protobuf::uint64 AppendEntriesRequest::prev_log_index() const {
  return prev_log_index_;
}
inline void AppendEntriesRequest::set_prev_log_index(::google::protobuf::uint64 value) {
  set_has_prev_log_index();
  prev_log_index_ = value;
}

// required uint64 prev_log_term = 5;
inline bool AppendEntriesRequest::has_prev_log_term() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AppendEntriesRequest::set_has_prev_log_term() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AppendEntriesRequest::clear_has_prev_log_term() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AppendEntriesRequest::clear_prev_log_term() {
  prev_log_term_ = GOOGLE_ULONGLONG(0);
  clear_has_prev_log_term();
}
inline ::google::protobuf::uint64 AppendEntriesRequest::prev_log_term() const {
  return prev_log_term_;
}
inline void AppendEntriesRequest::set_prev_log_term(::google::protobuf::uint64 value) {
  set_has_prev_log_term();
  prev_log_term_ = value;
}

// required uint64 commit_index = 6;
inline bool AppendEntriesRequest::has_commit_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AppendEntriesRequest::set_has_commit_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AppendEntriesRequest::clear_has_commit_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AppendEntriesRequest::clear_commit_index() {
  commit_index_ = GOOGLE_ULONGLONG(0);
  clear_has_commit_index();
}
inline ::google::protobuf::uint64 AppendEntriesRequest::commit_index() const {
  return commit_index_;
}
inline void AppendEntriesRequest::set_commit_index(::google::protobuf::uint64 value) {
  set_has_commit_index();
  commit_index_ = value;
}

// repeated .floyd.raft.Entry entries = 7;
inline int AppendEntriesRequest::entries_size() const {
  return entries_.size();
}
inline void AppendEntriesRequest::clear_entries() {
  entries_.Clear();
}
inline const ::floyd::raft::Entry& AppendEntriesRequest::entries(int index) const {
  return entries_.Get(index);
}
inline ::floyd::raft::Entry* AppendEntriesRequest::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::floyd::raft::Entry* AppendEntriesRequest::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::floyd::raft::Entry >&
AppendEntriesRequest::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::floyd::raft::Entry >*
AppendEntriesRequest::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// AppendEntriesResponse

// required bool status = 1;
inline bool AppendEntriesResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppendEntriesResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppendEntriesResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppendEntriesResponse::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool AppendEntriesResponse::status() const {
  return status_;
}
inline void AppendEntriesResponse::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// required uint64 term = 2;
inline bool AppendEntriesResponse::has_term() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppendEntriesResponse::set_has_term() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppendEntriesResponse::clear_has_term() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppendEntriesResponse::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::uint64 AppendEntriesResponse::term() const {
  return term_;
}
inline void AppendEntriesResponse::set_term(::google::protobuf::uint64 value) {
  set_has_term();
  term_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace raft
}  // namespace floyd

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::floyd::raft::Entry_Type>() {
  return ::floyd::raft::Entry_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_raft_2fraft_2eproto__INCLUDED
